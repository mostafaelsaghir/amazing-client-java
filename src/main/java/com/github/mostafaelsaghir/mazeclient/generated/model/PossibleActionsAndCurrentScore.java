/*
 * A-maze-ing API
 * This document describes the API of the A-maze-ing evening server.    This API consists of three different endpoints, which are detailed below.   - To register yourself as a player use the Player endpoint.   - To get information about the available mazes and enter a specific maze use the Mazes endpoint.   - To navigate a maze use the Maze endpoint.
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.github.mostafaelsaghir.mazeclient.generated.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;
import java.util.Objects;

/**
 * From the current tile where you stand, what actions are available on it and on the surrounding tiles.
 */
@ApiModel(description = "From the current tile where you stand, what actions are available on it and on the surrounding tiles.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2021-08-12T19:03:45.973+02:00")
@Data
public class PossibleActionsAndCurrentScore {
  @JsonProperty("possibleMoveActions")
  private List<MoveAction> possibleMoveActions = null;

  @JsonProperty("canCollectScoreHere")
  private Boolean canCollectScoreHere = null;

  @JsonProperty("canExitMazeHere")
  private Boolean canExitMazeHere = null;

  @JsonProperty("currentScoreInHand")
  private Integer currentScoreInHand = null;

  @JsonProperty("currentScoreInBag")
  private Integer currentScoreInBag = null;

  @JsonProperty("tagOnCurrentTile")
  private Long tagOnCurrentTile = null;

   /**
   * The actions available on your surrounding tiles (lookahead of one tile).
   * @return possibleMoveActions
  **/
  @ApiModelProperty(value = "The actions available on your surrounding tiles (lookahead of one tile).")
  public List<MoveAction> getPossibleMoveActions() {
    return possibleMoveActions;
  }

   /**
   * In the tile where you are standing, is it possible to collect score (from hand to bag).
   * @return canCollectScoreHere
  **/
  @ApiModelProperty(value = "In the tile where you are standing, is it possible to collect score (from hand to bag).")
  public Boolean isCanCollectScoreHere() {
    return canCollectScoreHere;
  }

   /**
   * In the tile where you are standing, is it possible to exit the maze. Remember you will lose any score in hand  and only be rewarded with the score you have in your bag.
   * @return canExitMazeHere
  **/
  @ApiModelProperty(value = "In the tile where you are standing, is it possible to exit the maze. Remember you will lose any score in hand  and only be rewarded with the score you have in your bag.")
  public Boolean isCanExitMazeHere() {
    return canExitMazeHere;
  }

   /**
   * What is the score you currently have in your hand. Find a score collection point and issue a collect  score command to move this score into your bag. Score in your hand is not awarded when you exit a maze.
   * @return currentScoreInHand
  **/
  @ApiModelProperty(value = "What is the score you currently have in your hand. Find a score collection point and issue a collect  score command to move this score into your bag. Score in your hand is not awarded when you exit a maze.")
  public Integer getCurrentScoreInHand() {
    return currentScoreInHand;
  }

   /**
   * What is the score currently in your bag. When you exit the maze this score will be rewarded to your total  overall score.
   * @return currentScoreInBag
  **/
  @ApiModelProperty(value = "What is the score currently in your bag. When you exit the maze this score will be rewarded to your total  overall score.")
  public Integer getCurrentScoreInBag() {
    return currentScoreInBag;
  }

   /**
   * The tag on the current tile
   * @return tagOnCurrentTile
  **/
  @ApiModelProperty(value = "The tag on the current tile")
  public Long getTagOnCurrentTile() {
    return tagOnCurrentTile;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PossibleActionsAndCurrentScore possibleActionsAndCurrentScore = (PossibleActionsAndCurrentScore) o;
    return Objects.equals(this.possibleMoveActions, possibleActionsAndCurrentScore.possibleMoveActions) &&
        Objects.equals(this.canCollectScoreHere, possibleActionsAndCurrentScore.canCollectScoreHere) &&
        Objects.equals(this.canExitMazeHere, possibleActionsAndCurrentScore.canExitMazeHere) &&
        Objects.equals(this.currentScoreInHand, possibleActionsAndCurrentScore.currentScoreInHand) &&
        Objects.equals(this.currentScoreInBag, possibleActionsAndCurrentScore.currentScoreInBag) &&
        Objects.equals(this.tagOnCurrentTile, possibleActionsAndCurrentScore.tagOnCurrentTile);
  }

  @Override
  public int hashCode() {
    return Objects.hash(possibleMoveActions, canCollectScoreHere, canExitMazeHere, currentScoreInHand, currentScoreInBag, tagOnCurrentTile);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PossibleActionsAndCurrentScore {\n");

    sb.append("    possibleMoveActions: ").append(toIndentedString(possibleMoveActions)).append("\n");
    sb.append("    canCollectScoreHere: ").append(toIndentedString(canCollectScoreHere)).append("\n");
    sb.append("    canExitMazeHere: ").append(toIndentedString(canExitMazeHere)).append("\n");
    sb.append("    currentScoreInHand: ").append(toIndentedString(currentScoreInHand)).append("\n");
    sb.append("    currentScoreInBag: ").append(toIndentedString(currentScoreInBag)).append("\n");
    sb.append("    tagOnCurrentTile: ").append(toIndentedString(tagOnCurrentTile)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

